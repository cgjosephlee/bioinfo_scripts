#!/usr/bin/env python3
"""
MitoZ.py

Copyright (c) 2017-2019 Guanliang Meng <mengguanliang@foxmail.com>.

This file is part of MitoZ.

MitoZ is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

MitoZ is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with MitoZ.  If not, see <http://www.gnu.org/licenses/>.

"""

import argparse
import sys
import os
import re
import subprocess
import time
from glob import glob

try:
	import Bio
	from Bio import SeqIO
except:
	sys.exit("package biopython not found! Please install it!")

try:
	from ete3 import NCBITaxa
except:
	sys.exit('''package ete3 not found! Please install it!
Then setting up a local copy of the NCBI taxonomy database followging
http://etetoolkit.org/docs/latest/tutorial/tutorial_ncbitaxonomy.html''')


def config2CL(module=None, config_file=None):
	start_flag = '[module-{module}-BEGIN]'.format(module=module)
	end_flag = '[module-{module}-END]'.format(module=module)
	para = [module]
	tmp = 0
	with open(config_file, 'r') as fh:
		for i in fh:
			i = i.strip()
			if not i or i.startswith('#'):
				continue

			if start_flag in i:
				tmp = 1
				continue

			if end_flag in i:
				tmp = 0
				break

			if tmp:
				try:
					m = re.search(r'^(\w+)\s*=\s*(.*)$', i)
					key = m.group(1)
					val = m.group(2)
				except AttributeError:
					sys.exit('wrong line in the config file\n'+i)

				if val:
					para.append('--{key}'.format(key=key))
					if val != 'True':
						para.append(val)

	print('command lines options:\n', ' '.join(para), '\n', sep='')
	return para

def create_config(module=None):
	orginal_config_file = os.path.join(sys.path[0], 'MitoZ.config.default')
	start_flag = '[module-{module}-BEGIN]'.format(module=module)
	end_flag = '[module-{module}-END]'.format(module=module)
	tmp = 0
	content = ''
	count = 0
	with open(orginal_config_file, 'r') as fh:
		for i in fh:
			count += 1
			if count <= 3:
				content += i

			if start_flag in i:
				tmp = 1
				content += '\n' + i
				continue

			if end_flag in i:
				tmp = 0
				content += i
				break

			if tmp:
				content += i

	with open('mitoz_'+module+'_config.txt', 'w') as fhout:
		print(content, file=fhout)


###############################################################################
#####------------------------- parameters --------------------------------#####

## common group
common_parser = argparse.ArgumentParser(add_help=False,
	formatter_class=argparse.RawTextHelpFormatter)

common_group = common_parser.add_argument_group('Common arguments')

common_group.add_argument("--outprefix", metavar="<STR>", required=True,
	help="output prefix")

common_group.add_argument("--thread_number", metavar="<INT>", default="8",
	help="thread number [%(default)s]")

common_group.add_argument("--create_config", action='store_true', help='''create the config file for a specific module if you want to use '--config' option to specify parameters.''')

common_group.add_argument("--config", metavar="<file>",
	help='''read all parameters from config file, which can be generated by '--create_config'. Other command lines options will be ignored!''')


## fastq group
fastq_parser = argparse.ArgumentParser(add_help=False,
	formatter_class=argparse.RawTextHelpFormatter)

fastq_group = fastq_parser.add_argument_group('Input fastq files')

fastq_group.add_argument("--fastq1", metavar="<STR>", default='', help="fastq 1 file")

fastq_group.add_argument("--fastq2", metavar="<STR>", default='', help="fastq 2 file")

fastq_group.add_argument("--fastq_quality_shift", default=False,
	action="store_true", help="the input is in the Illumina 1.3+" +\
	" FASTQ-like (Q+64) format. (default: Q+33)")

fastq_group.add_argument("--fastq_read_length", metavar="<INT>", default='150',
	help='''read length of fastq reads, used by SOAPTrans and bwa.
It must be >= 71 bp [%(default)s]''')

fastq_group.add_argument("--fq_size", metavar="<float>", default=5, type=float,
	help="use only part (# Gbp) of the input fastq file in the analysis. Generally, 2~7 G data should be enough, using more data may only consume more memory. Support for all, all2, filter, assemble and findmitoscaf [%(default)s]")


# fasta file group
fastafile_parser = argparse.ArgumentParser(add_help=False,
	formatter_class=argparse.RawTextHelpFormatter)

fastafile_group = fastafile_parser.add_argument_group('Input fasta file')

fastafile_group.add_argument('--fastafile', metavar="<STR>", help="fasta file")


## filter group
filter_parser = argparse.ArgumentParser(add_help=False,
	formatter_class=argparse.RawTextHelpFormatter)

filter_group = filter_parser.add_argument_group('Filter arguments')

filter_group.add_argument("--adapter1", metavar="<STR>",
	help='''input 1.adapter.list.gz file. will not filter adapter
contamination if not provided''')

filter_group.add_argument("--adapter2", metavar="<STR>",
	help='''input 2.adapter.list.gz file. will not filter adapter
contamination if not provided''')

filter_group.add_argument("--fastq3", metavar="<STR>", default="clean.1.fq.gz",
	help="output read1 fastq file [%(default)s]")

filter_group.add_argument("--fastq4", metavar="<STR>", default="clean.2.fq.gz",
	help="output read2 fastq file [%(default)s]")

filter_group.add_argument("--duplication", default=False, action="store_true",
	help='''filter duplications (caused by PCRs After adapter ligation,
thudirections of read1 & read2 of duplications should be completely
identical)''')

filter_group.add_argument("--adapter_mismatch", default="3", metavar="<INT>",
	help="cut-off adapter mis-match bases [%(default)s]")

filter_group.add_argument("--adapter_length", default="15", metavar="<INT>",
	help="cut-off adapter align length [%(default)s]")

filter_group.add_argument("--keep_region", default="full_length_read",
	metavar="<BEG,END>", help="keep only bases between BEG and END" +\
	" for each read [%(default)s]")

filter_group.add_argument("--Ns_number", default="10", metavar="<INT>",
	help="the maximun N allowed in single end reads [%(default)s")

filter_group.add_argument("--low_quality", default="55,20",
	metavar="<QUAL,CONT>",
	help='''the maixmum percentage of low quality
(ASCII code's integer) bases allowed in single end reads [%(default)s]''')


## assembly group
assembly_parser = argparse.ArgumentParser(add_help=False,
	formatter_class=argparse.RawTextHelpFormatter)

assembly_group = assembly_parser.add_argument_group('Assembly arguments')

assembly_group.add_argument("--insert_size", metavar="<INT>", default='250',
	help="insert size of input fastq files [%(default)s]")

assembly_group.add_argument("--soaptrans_thread_number", metavar="<INT>",
	default='8', help=argparse.SUPPRESS)

assembly_group.add_argument("--run_mode", type=int,
	metavar="<INT>", default=2, choices=[2, 3],
	help='2 for quick_mode, 3 for multi-kmer mode [%(default)s]')

assembly_group.add_argument('--missing_PCGs', metavar='gene', nargs='*',
	help='''when use '--run_mode 3', you MUST provide the missing
protein coding genes names, they could be:
ATP6 ATP8 COX1 COX2 COX3 CYTB ND1 ND2 ND3 ND4 ND4L ND5 ND6''')

assembly_group.add_argument('--quick_mode_seq_file', metavar='[file]',
	default='',
	help='''when use '--run_mode 3', you should provide the fasta sequences
from quick mode (if any).''')

assembly_group.add_argument('--quick_mode_fa_genes_file', metavar='[file]',
	default='',
	help='''when use '--quick_mode_seq_file', you should also provide the
protein coding genes names for each fasta sequence. per-line format:
seqid gene1 gene2''')

assembly_group.add_argument('--quick_mode_score_file', metavar='[file]',
	default='',
	help='''when use '--run_mode 3', you should provide the score file
from quick mode (if any). e.g. the 'high_abundance' scores ''')

assembly_group.add_argument('--quick_mode_prior_seq_file', metavar='[file]',
	default='',
	help='''when use '--run_mode 3', you should provide the sequence file
which the '--quick_mode_score_file' is corresponding to in the quick mode
(if any).''')

## search_mito_group
search_mito_parser = argparse.ArgumentParser(add_help=False,
	formatter_class=argparse.RawTextHelpFormatter)

search_mito_group = search_mito_parser.add_argument_group('Search' +\
	' mitochondrial sequences arguments')

search_mito_group.add_argument("--filter_taxa_method", choices=[1,3],
	default=1, type=int,
	help='''1: filter out non-requiring_taxa sequences by mito-PCGs annotation
to do taxa assignment. 3: do not filter [%(default)s]''')

search_mito_group.add_argument('--min_abundance', metavar='<float>',
	type=float, default=10,
	help='the minimum abundance of sequence required [%(default)s]')
#search_mito_group.add_argument("--cds_completeness_percentage",
#	metavar="<INT>", type=int, default=70, help=argparse.SUPPRESS)
						#help="filter nhmmer result by length completeness" +\
						#" percent of annotated CDS. 0 for no filter." +\
						#" (default: %(default)s)")

search_mito_group.add_argument("--requiring_taxa", metavar="<STR>",
	default="Arthropoda",
	help='''filtering out non-requiring taxa sequences which may be
contamination [%(default)s]''')

search_mito_group.add_argument("--requiring_relax", default="0",
	choices=["0", "1", "2", "3", "4", "5", "6"],
	help='''The relaxing threshold for filtering non-target-requiring_taxa.
The larger digital means more relaxing. [%(default)s]''')


## search_and_annot_mito_group
search_and_annot_mito_parser = argparse.ArgumentParser(add_help=False,
	formatter_class=argparse.RawTextHelpFormatter)

search_and_annot_mito_parser.add_argument("--genetic_code", metavar="<INT>",
	default="auto",
	help='''which genetic code table to use? 'auto' means determined by
'--clade' option. [%(default)s]''')

search_and_annot_mito_parser.add_argument("--clade", default="Arthropoda",
	choices=["Chordata", "Arthropoda", "Echinodermata", "Annelida-segmented-worms", "Bryozoa", "Mollusca", "Nematoda", "Nemertea-ribbon-worms", "Porifera-sponges"],
	help="which clade does your species belong to? [%(default)s]")


## annotation group
annotation_parser = argparse.ArgumentParser(add_help=False,
	formatter_class=argparse.RawTextHelpFormatter)

annotation_group = annotation_parser.add_argument_group('Annotation arguments')

annotation_group.add_argument("--annotation", default=True,
	action="store_false", help="do annotation or not? [%(default)s]")

annotation_group.add_argument("--species_name", metavar="<STR>",
	default="Test sp.",
	help='''species name to use in output genbank file ['%(default)s']''')


#####------------------------- parameters --------------------------------#####
###############################################################################

###############################################################################
#####----------------------- main subcommand parsers --------------------######

# textwrap.dedent
description = """
Description

	MitoZ - A toolkit for animal mitochondrial genome assembly,
annotation and visualization

Version
	2.4

Citation

Guanliang Meng, Yiyuan Li, Chentao Yang, Shanlin Liu.
MitoZ: a toolkit for animal mitochondrial genome assembly,
annotation and visualization; doi: https://doi.org/10.1093/nar/gkz173
"""


parser = argparse.ArgumentParser(prog="MitoZ", description=description,
		formatter_class=argparse.RawTextHelpFormatter)

# parser.add_argument("--version", action="version", version="%(prog)s 2.0")

subparsers = parser.add_subparsers(dest='command')


########## subcommmands ###########

## all subcommand
parser_all = subparsers.add_parser("all",
	parents=[common_parser, fastq_parser,
		filter_parser, assembly_parser,search_mito_parser,
		search_and_annot_mito_parser,annotation_parser],
	help="run filter, assemble and annotate")

parser_all.add_argument("--topology", choices=["linear", "circular"],
	default="linear", help=argparse.SUPPRESS)
					#help="the sequences are circular?" +\
					#" (seq length >= 12Kbp) (default: %(default)s)")

parser_all.add_argument("--usepre", default=False, action="store_true",
	help='''use previous results (clean data / first assembly by
SOAPTrans). Otherwise I will delete all previous result files and run from the
very beginning (default: %(default)s)''')

parser_all.add_argument("--from_soaptrans", default=True,
					action="store_true", help=argparse.SUPPRESS)


## all2 subcommand
parser_all2 = subparsers.add_parser("all2",
	parents=[common_parser,
		fastq_parser, assembly_parser, search_mito_parser,
		search_and_annot_mito_parser, annotation_parser],
	help="run assemble and annotate")

parser_all2.add_argument("--topology", choices=["linear", "circular"],
	default="linear", help=argparse.SUPPRESS)

parser_all2.add_argument("--usepre", default=False, action="store_true",
	help='''use previous results (clean data / first assembly by SOAPTrans)
Otherwise I will delete all previous result files and run from the
very beginning (default: %(default)s)''')

parser_all2.add_argument("--from_soaptrans", default=True,
	action="store_true", help=argparse.SUPPRESS)


## filter subcommand
parser_filter = subparsers.add_parser("filter",
	parents=[common_parser,fastq_parser, filter_parser],
	help="filter raw reads")


## assembly subcommand
parser_assemble = subparsers.add_parser("assemble",
	parents=[
		common_parser,
		fastq_parser,
		assembly_parser,
		search_mito_parser,
		search_and_annot_mito_parser],
	help="do assembly from input fastq reads," +\
	" output mitosequences.")

parser_assemble.add_argument("--usepre", default=False, action="store_true",
	help='''use previous results (clean data / first assembly by SOAPTrans)
Otherwise I will delete all previous result files and run from the very
beginning (default: %(default)s)''')

parser_findmitoscaf = subparsers.add_parser("findmitoscaf",
	parents=[
		common_parser,
		fastafile_parser,
		fastq_parser,
		search_mito_parser,
		search_and_annot_mito_parser],
	help='''Search for mitochondrial sequences from assembly.
About 2-3 Gbp fastq data is needed to calculate the average
sequencing depth of each sequences, otherwise,
'--from_soaptrans' should be used.''')

parser_findmitoscaf.add_argument("--from_soaptrans",
	default=False,
	action="store_true",
	help='''is the input fasta generated by SOAPTrans?
if not, '--fastq1' and '--fastq2' must be set! (default: %(default)s)''')


## annotation subcommand
parser_annotate = subparsers.add_parser("annotate",
	parents=[common_parser,
		fastafile_parser, annotation_parser,
		search_and_annot_mito_parser],
	help="annotate PCGs, tRNA and rRNA genes.")

parser_annotate.add_argument("--fastq1", metavar="<STR>", help="fastq 1 file, if you want to draw depth.")

parser_annotate.add_argument("--fastq2", metavar="<STR>", help="fastq 2 file, if you want to draw depth.")

parser_annotate.add_argument("--depth_file", metavar="<STR>",
	help=argparse.SUPPRESS)
					#help="file of sequencing depth along the sequences")

parser_annotate.add_argument("--topology", choices=["linear", "circular"],
	default="linear",
	help='''the sequences are circular? (seq length must be >= 12Kbp)
(default: %(default)s)''')


## visualize subcommand
parser_visualize = subparsers.add_parser("visualize",
	help="visualization of GenBank file")

#####----------------------- main subcommand parsers --------------------######
###############################################################################



###############################################################################
#####---------------------- other subcommand parsers ---------------------#####

# parser_reconfirm = subparsers.add_parser("reconfirm",
# 	parents=[common_parser, fastafile_parser, fastq_parser],
# 	help="reconfirm assembly by mapping reads to sequences")

# parser_circle = subparsers.add_parser("circle",
#	parents=[common_parser, fastafile_parser, fastq_group],
#	help="check if sequences are circular")


#####---------------------- other subcommand parsers ---------------------#####
###############################################################################


###############################################################################
###############################################################################
#####---------------------- program execution start ----------------------#####


######################## argument checking  ###################################

python3 = sys.executable

work_dir = os.getcwd()

## bin directories
bin_dir = os.path.join(sys.path[0], 'bin')
bin_filter_dir = os.path.join(bin_dir, "filter")
bin_assemble_dir = os.path.join(bin_dir, "assemble")
bin_findmitoscaf_dir = os.path.join(bin_dir, "findmitoscaf")
bin_annotate_dir = os.path.join(bin_dir, "annotate")
bin_common_dir = os.path.join(bin_dir, "common")
bin_profiles_dir = os.path.join(bin_dir, "profiles")
bin_visualize_dir = os.path.join(bin_dir, 'visualize')


## import module
sys.path.append(bin_visualize_dir)
import MitoZ_visualize

if len(sys.argv) == 1:
	parser.print_help()
	parser.exit()

if len(sys.argv) == 3 and sys.argv[2] == '--create_config':
	create_config(module=sys.argv[1])
	sys.exit(0)

if len(sys.argv) >= 3 and sys.argv[2] == '--config':
	para_list = config2CL(module=sys.argv[1], config_file=sys.argv[3])

if sys.argv[1] == 'visualize':
	if len(sys.argv) >= 3 and sys.argv[2] == '--config':
		MitoZ_visualize.main(para_list=para_list[1:])
	else:
		MitoZ_visualize.main(para_list=sys.argv[2:])
	sys.exit(0)

if len(sys.argv) >= 3 and sys.argv[2] == '--config':
	args = parser.parse_args(para_list)
else:
	args = parser.parse_args()

## directory will create
workdir_tmp = args.outprefix + '.tmp'
if os.path.exists(workdir_tmp):
	sys.exit('{0} directory exists, please remove it firstly!'.format(workdir_tmp))
os.mkdir(workdir_tmp)

work_dir_tmp = os.path.join(work_dir, workdir_tmp)
partial_fastq_wdir = os.path.join(work_dir_tmp, args.outprefix + ".partial_fastq")
clean_data_wdir = os.path.join(work_dir_tmp, args.outprefix + ".cleandata")
assemble_wdir = os.path.join(work_dir_tmp, args.outprefix + ".assembly")
# created if needed
assemble_wdir2 = os.path.join(work_dir_tmp, args.outprefix + ".assembly2")
annotate_wdir = os.path.join(work_dir_tmp, args.outprefix + ".annotation")
result_wdir = os.path.join(work_dir, args.outprefix + ".result")


## softwares and databases
errors_found = 0
def check_program_invoked(cmd):
	result = subprocess.call('type %s' % cmd, shell = True,
			stdout = subprocess.PIPE, stderr = subprocess.PIPE) == 0
	if result:
		return 0
	else:
		print(cmd, " not found!", file=sys.stderr)
		return 1


def files_exist_0_or_1(filelist):
	num = 0
	for file in filelist:
		if os.path.exists(file):
			num += 1
		else:
			print("%s doesn't exist!" % file, file=sys.stderr)
	if len(filelist) == num:
		return 0
	else:
		return 1


def directory_exist_check(*directories):
	err = 0
	for directory in directories:
		if os.path.exists(directory):
			print("Directory %s exists, please delete it!" % directory,
				file=sys.stderr)
			err += 1
	if err > 0:
		sys.exit('Exit!')

def abspath(*files):
	flist = []
	for file in files:
		file = os.path.abspath(file)
		flist.append(file)
	if len(flist) > 1:
		return flist[:]
	else:
		return flist[0]

def runcmd(command):
	try:
		current_time = time.strftime("%Y-%m-%d %H:%M:%S",
						time.localtime(time.time()))
		print(current_time, "\n", command, "\n", sep="", flush=True)
		subprocess.check_call(command, shell=True)
	except:
		sys.exit("Error occured when running command:\n%s" % command)

def runcmd2(command):
	try:
		current_time = time.strftime("%Y-%m-%d %H:%M:%S",
						time.localtime(time.time()))
		print(current_time, "\n", command, "\n", sep="", flush=True)
		subprocess.call(command, shell=True)
	except:
		sys.exit("Error occured when running command:\n%s" % command)


def pre_del_cmd(prefix=None, filestr=None):
	file_list = [prefix + '*' + j for j in filestr.split()]
	file_list = " ".join(file_list)
	command = "rm -rf " + file_list
	return command


soaptrans = os.path.join(bin_assemble_dir, "mitoAssemble")
bwa = 'bwa'
samtools = 'samtools'
MT_annotation_BGI= os.path.join(bin_annotate_dir,
				"MT_annotation_BGI_V1.32/MT_annotation_BGI.pl")

MT_annotation_BGI_pro_db_for_filter_taxa = os.path.join(bin_profiles_dir,
	"MT_database", "Animal_CDS_protein.fa")

if hasattr(args, "clade"):
	MT_annotation_BGI_pro_db_for_final_annotation = os.path.join(bin_profiles_dir, "MT_database", args.clade +"_CDS_protein.fa")

nhmmer = 'nhmmer'
blastn = 'blastn'
cmsearch = 'cmsearch'

## HMM profiles
if hasattr(args, "clade"):
	# used by findmitoscaf
	nhmmer_profile = os.path.join(bin_profiles_dir, 'CDS_HMM',
		args.clade+"_CDS.hmm") #args.clade+".hmm")
	# used by findmitoscaf
	defined_gene_length_f = os.path.join(bin_profiles_dir, 'CDS_HMM',
		args.clade+"_CDS_length_list")
# used by annotate
s_rRNA_CM = os.path.join(bin_profiles_dir, 'rRNA_CM', "v1.1_12snew.cm")
# used by annotate
l_rRNA_CM = os.path.join(bin_profiles_dir, 'rRNA_CM',  "v1.1_16snew.cm")


## genetic code selection
genetic_code_dict = {"Chordata":"2", "Arthropoda":"5", "Echinodermata":"9",
	"Annelida-segmented-worms":"5", "Bryozoa":"5", "Mollusca":"5",
	"Nematoda":"5", "Nemertea-ribbon-worms":"5", "Porifera-sponges":"4"}

if hasattr(args, "genetic_code") and args.genetic_code == "auto":
	args.genetic_code = genetic_code_dict[args.clade]


## get absolute path of input files
if hasattr(args, "fastq1") and args.fastq1 and os.path.isfile(args.fastq1):
	args.fastq1 = abspath(args.fastq1)
if hasattr(args, "fastq2") and args.fastq2 and os.path.isfile(args.fastq2):
	args.fastq2 = abspath(args.fastq2)
if hasattr(args, "adapter1") and args.adapter1:
	args.adapter1 = abspath(args.adapter1)
	args.adapter2 = abspath(args.adapter2)
if hasattr(args, "fastafile") and args.fastafile:
	args.fastafile = abspath(args.fastafile)

if hasattr(args, 'quick_mode_seq_file') and args.quick_mode_seq_file:
		args.quick_mode_seq_file = abspath(args.quick_mode_seq_file)

if hasattr(args, 'quick_mode_fa_genes_file') and args.quick_mode_fa_genes_file:
		args.quick_mode_fa_genes_file = abspath(args.quick_mode_fa_genes_file)

if hasattr(args, 'quick_mode_score_file') and args.quick_mode_score_file:
		args.quick_mode_score_file = abspath(args.quick_mode_score_file)

if hasattr(args, 'quick_mode_prior_seq_file') and args.quick_mode_prior_seq_file:
		args.quick_mode_prior_seq_file = abspath(args.quick_mode_prior_seq_file)


## file existing check
if args.command == 'all':
	# the order is important
	if args.fastq1 and os.path.isfile(args.fastq1) and args.fastq2 and os.path.isfile(args.fastq2):
		errors_found += files_exist_0_or_1([args.fastq1, args.fastq2,
			nhmmer_profile, defined_gene_length_f, s_rRNA_CM, l_rRNA_CM])

	elif args.fastq1 and os.path.isfile(args.fastq1):
		errors_found += files_exist_0_or_1([args.fastq1,
			nhmmer_profile, defined_gene_length_f, s_rRNA_CM, l_rRNA_CM])

	elif args.fastq2 and os.path.isfile(args.fastq2):
		errors_found += files_exist_0_or_1([args.fastq2,
			nhmmer_profile, defined_gene_length_f, s_rRNA_CM, l_rRNA_CM])

elif args.command == "all2":
	# the order is important
	if args.fastq1 and os.path.isfile(args.fastq1) and args.fastq2 and os.path.isfile(args.fastq2):
		errors_found += files_exist_0_or_1([args.fastq1, args.fastq2,
			nhmmer_profile, defined_gene_length_f, s_rRNA_CM, l_rRNA_CM])

	elif args.fastq1 and os.path.isfile(args.fastq1):
		errors_found += files_exist_0_or_1([args.fastq1,
			nhmmer_profile, defined_gene_length_f, s_rRNA_CM, l_rRNA_CM])

	elif args.fastq2 and os.path.isfile(args.fastq2):
		errors_found += files_exist_0_or_1([args.fastq2,
			nhmmer_profile, defined_gene_length_f, s_rRNA_CM, l_rRNA_CM])

elif args.command == 'filter':
	errors_found += files_exist_0_or_1([args.fastq1, args.fastq2])

elif args.command == 'assemble':
	# order is important
	if args.fastq1 and os.path.isfile(args.fastq1) and args.fastq2 and os.path.isfile(args.fastq2):
		errors_found += files_exist_0_or_1([args.fastq1, args.fastq2,])

	elif args.fastq1 and os.path.isfile(args.fastq1):
		errors_found += files_exist_0_or_1([args.fastq1,])

	elif args.fastq2 and os.path.isfile(args.fastq2):
		errors_found += files_exist_0_or_1([args.fastq2,])

elif args.command == "findmitoscaf":
	errors_found += files_exist_0_or_1([args.fastafile, nhmmer_profile,
		defined_gene_length_f])

elif args.command == 'circle':
	errors_found += files_exist_0_or_1([args.fastafile])

elif args.command == 'annotate':
	errors_found += files_exist_0_or_1([args.fastafile, s_rRNA_CM, l_rRNA_CM])

elif args.command == 'reconfirm':
	# order is important
	if args.fastq1 and os.path.isfile(args.fastq1) and args.fastq1 and os.path.isfile(args.fastq2):
		errors_found += files_exist_0_or_1([args.fastq1, args.fastq2,
			args.fastafile])

	elif args.fastq1 and os.path.isfile(args.fastq1):
		errors_found += files_exist_0_or_1([args.fastq1,args.fastafile])

	elif args.fastq2 and os.path.isfile(args.fastq2):
		errors_found += files_exist_0_or_1([args.fastq2,args.fastafile])

elif args.command == "clean":
	pass
else:
	parser.print_help()
	parser.exit()

if errors_found > 0:
	parser.exit("Errors found! Exit!")


# extract only part of fastq data for the whole analysis
# should update the args variable for the fastq file path
# the script should support for single end data: extractfq.py

if hasattr(args, "fq_size") and args.fq_size>0 :
	os.mkdir(partial_fastq_wdir)
	soft = os.path.join(bin_common_dir, "extractfq.py")
	outfq1 = os.path.join(partial_fastq_wdir, 'partial.1.fq')
	outfq2 = os.path.join(partial_fastq_wdir, 'partial.2.fq')

	# the order is important
	if args.fastq1 and os.path.isfile(args.fastq1) and args.fastq2 and os.path.isfile(args.fastq2):
		command = python3 + " " + soft +\
			" -fq1 " + args.fastq1 +\
			" -fq2 " + args.fastq2 +\
			" -outfq1 " + outfq1 +\
			" -outfq2 " + outfq2 +\
			" -size_required " + str(args.fq_size)  +\
			" -cache_num 1500000 "
		runcmd(command)
		args.fastq1 = outfq1
		args.fastq2 = outfq2

	elif args.fastq1 and os.path.isfile(args.fastq1):
		command = python3 + " " + soft +\
			" -fq1 " + args.fastq1 +\
			" -outfq1 " + outfq1 +\
			" -size_required " + str(args.fq_size)  +\
			" -cache_num 1500000 "
		runcmd(command)
		args.fastq1 = outfq1

	elif args.fastq2 and os.path.isfile(args.fastq2):
		command = python3 + " " + soft +\
			" -fq1 " + args.fastq2 +\
			" -outfq1 " + outfq2 +\
			" -size_required " + str(args.fq_size)  +\
			" -cache_num 1500000 "
		runcmd(command)
		args.fastq2 = outfq2

###############################################################################
#####---------------------------- filter ---------------------------------#####


def filter_rawdata(bin_filter_dir=None, clean_data_wdir=None, raw_fq1=None, raw_fq2=None, adapter1=None, adapter2=None, clean_fq1=None, clean_fq2=None, usepre=False, adapter_mismatch=None, adapter_length=None, Ns_number=None, low_quality=None, keep_region=None, duplication=False):
	"""
	Filter raw data. Beware: can not filter adapter contaminations if
	adapter.list.gz are not provided

	"""

	clean_fq1 = os.path.join(clean_data_wdir, os.path.basename(clean_fq1))
	clean_fq2 = os.path.join(clean_data_wdir, os.path.basename(clean_fq2))

	if usepre:
		if not files_exist_0_or_1([clean_fq1, clean_fq2]):
			print("use previous result:\n\t" + clean_fq1 + "\n\t" +\
				 clean_fq2 + "\n", flush=True)
			return (abspath(clean_fq1, clean_fq2))
		else:
			os.mkdir(clean_data_wdir)
	else:
		os.mkdir(clean_data_wdir)

	os.chdir(clean_data_wdir)

	if (not raw_fq1) and raw_fq2:
		raw_fq1 = raw_fq2
		raw_fq2 = None

	if raw_fq1 and not raw_fq2:
		# single end data
		soft = os.path.join(bin_filter_dir, "raw_reads_filter_SE_v0.5.pl")
		command = "perl " + soft +\
				" -1 " + raw_fq1 +\
				" -3 " + clean_fq1 +\
				" -n " + Ns_number +\
				" -q " + low_quality +\
				" -z "
		if keep_region != "full_length_read":
			command += " -k " + keep_region

		runcmd(command)

		return (abspath(clean_fq1), None)


	soft = os.path.join(bin_filter_dir, "raw_reads_filter_v0.5.pl")
	command = "perl " + soft +\
			" -1 " + raw_fq1 +\
			" -2 " + raw_fq2 +\
			" -3 " + clean_fq1 +\
			" -4 " + clean_fq2 +\
			" -m " + adapter_mismatch +\
			" -l " + adapter_length +\
			" -n " + Ns_number +\
			" -q " + low_quality +\
			" -z "
	if adapter1 and adapter2:
		command += " -a " + adapter1 + " -b " + adapter2
	if keep_region != "full_length_read":
		command += " -k " + keep_region
	if duplication:
		command += " -d "

	runcmd(command)

	return (abspath(clean_fq1, clean_fq2))


def assemble(assemble_wdir=None, assemble_wdir2=None, bin_assemble_dir=None, bin_findmitoscaf_dir=None, bin_annotate_dir=None, bin_common_dir=None, soaptrans=None, samtools=None, bwa=None, blastn=None, MT_annotation_BGI=None, soaptrans_thread_number=None, thread_number=None, fq1=None, fq2=None, fastq_read_length=None, fastq_quality_shift=None, insert_size=None, MT_annotation_BGI_pro_db=None, nhmmer_profile=None, requiring_taxa=None, requiring_relax=None, require_genetic_code=None, filter_taxa_method=None, run_mode=False, quick_mode_seq_file=None, quick_mode_fa_genes_file=None, missing_PCGs=None, quick_mode_score_file=None, quick_mode_prior_seq_file=None, usepre=False, outprefix=None, min_abundance=10):

	"""
	denovo assembly from input fastq reads, output mitosequences.

	"""
	soaptrans_thread_number = thread_number

	if run_mode == 2:
		# quick mode
		if usepre:
			if not os.path.exists(assemble_wdir):
				os.mkdir(assemble_wdir)
		else:
			os.mkdir(assemble_wdir)

		os.chdir(assemble_wdir)
		kmer = 71
		assembly_file = assemble_soaptrans(assemble_wdir=assemble_wdir,
			soaptrans=soaptrans,
			soaptrans_thread_number=soaptrans_thread_number,
			fq1=fq1,
			fq2=fq2,
			fastq_read_length=fastq_read_length,
			insert_size=insert_size,
			kmer=kmer,
			prefix="work"+str(kmer),
			usepre=usepre)

		mitoscaf_file, CDS_found_count, CDS_found_lengths_list = \
			findmitoscaf(bin_findmitoscaf_dir=bin_findmitoscaf_dir,
				bin_annotate_dir=bin_annotate_dir,
				bin_common_dir=bin_common_dir,
				assembly_file=assembly_file,
				from_soaptrans=True,
				fastq_quality_shift=fastq_quality_shift,
				nhmmer_profile=nhmmer_profile,
				requiring_taxa=requiring_taxa,
				require_genetic_code=require_genetic_code,
				requiring_relax=requiring_relax,
				MT_annotation_BGI=MT_annotation_BGI,
				MT_annotation_BGI_pro_db=MT_annotation_BGI_pro_db,
				filter_taxa_method=filter_taxa_method,
				blastn=blastn,
				samtools=samtools,
				bwa=bwa,
				thread_number=thread_number,
				prefix="work"+str(kmer),
				min_abundance=min_abundance)

		# when this change, remember change mito_min_len cutoff in
		# soaptrans_assemble_with_unmapped_reads()
		print("CDS_found_lengths_list: ", CDS_found_lengths_list)

		if not mitoscaf_file:
			sys.exit('quick mode got no result!')

		return abspath(mitoscaf_file)

	elif run_mode == 3:
		# multi-kmer mode
		if not missing_PCGs or len(missing_PCGs) < 1:
			sys.exit("you must set '--missing_PCGs' when use '--run_mode 3' !")

		os.mkdir(assemble_wdir2)
		os.chdir(assemble_wdir2)

		kmer = 31
		assembly_file2 = assemble_soaptrans(
			assemble_wdir=assemble_wdir2,
			soaptrans=soaptrans,
			soaptrans_thread_number=soaptrans_thread_number,
			fq1=fq1,
			fq2=fq2,
			fastq_read_length=fastq_read_length,
			insert_size=insert_size,
			kmer=kmer,
			prefix="work"+str(kmer),
			usepre=False)

		mitoscaf_file2, CDS_found_count, CDS_found_lengths = findmitoscaf(
				bin_findmitoscaf_dir=bin_findmitoscaf_dir,
				bin_annotate_dir=bin_annotate_dir,
				bin_common_dir=bin_common_dir,
				assembly_file=assembly_file2,
				from_soaptrans=True,
				fastq_quality_shift=fastq_quality_shift,
				nhmmer_profile=nhmmer_profile,
				requiring_taxa=requiring_taxa,
				require_genetic_code=require_genetic_code,
				requiring_relax=requiring_relax,
				MT_annotation_BGI=MT_annotation_BGI,
				MT_annotation_BGI_pro_db=MT_annotation_BGI_pro_db,
				filter_taxa_method=filter_taxa_method,
				blastn=blastn,
				samtools=samtools,
				bwa=bwa,
				thread_number=thread_number,
				prefix="work"+str(kmer),
				min_abundance=min_abundance)

		kmer = 91
		mitoscaf_file3 = ""
		if int(fastq_read_length) >= kmer:
			assembly_file3 = assemble_soaptrans(
				assemble_wdir=assemble_wdir2,
				soaptrans=soaptrans,
				soaptrans_thread_number=soaptrans_thread_number,
				fq1=fq1,
				fq2=fq2,
				fastq_read_length=fastq_read_length,
				insert_size=insert_size,
				kmer=kmer,
				prefix="work"+str(kmer),
				usepre=False)

			mitoscaf_file3, CDS_found_count, CDS_found_lengths = findmitoscaf(
				bin_findmitoscaf_dir=bin_findmitoscaf_dir,
				bin_annotate_dir=bin_annotate_dir,
				bin_common_dir=bin_common_dir,
				assembly_file=assembly_file3,
				from_soaptrans=True,
				fastq_quality_shift=fastq_quality_shift,
				nhmmer_profile=nhmmer_profile,
				requiring_taxa=requiring_taxa,
				require_genetic_code=require_genetic_code,
				requiring_relax=requiring_relax,
				MT_annotation_BGI=MT_annotation_BGI,
				MT_annotation_BGI_pro_db=MT_annotation_BGI_pro_db,
				filter_taxa_method=filter_taxa_method,
				blastn=blastn,
				samtools=samtools,
				bwa=bwa,
				thread_number=thread_number,
				prefix="work"+str(kmer),
				min_abundance=min_abundance)

		multiKmer_score_files = [quick_mode_score_file]
		multiKmer_seq_files = [quick_mode_prior_seq_file]
		for k in [31, 91]:
			score_file, seq_file = get_multiKmer_seq_and_score_files(nhmmer_result_dir=assemble_wdir2, kmer=k)
			multiKmer_score_files.append(score_file)
			multiKmer_seq_files.append(seq_file)

		soft = os.path.join(bin_assemble_dir, 'pick_missing_PCGs_from_multiKmer.py')

		if quick_mode_seq_file and quick_mode_fa_genes_file:
			command = python3 + " " + soft +\
				" --quick_mode_seq_file " + quick_mode_seq_file +\
				" --quick_mode_fa_genes_file " + quick_mode_fa_genes_file +\
				" --multiKmer_sorted_scores_files " + ' '.join(multiKmer_score_files) +\
				" --multiKmer_seqs_files " + ' '.join(multiKmer_seq_files) +\
				" --missing_genes " + ' '.join(missing_PCGs) +\
				" --outprefix " + outprefix +\
				" --blastn  " + blastn
		else:
			command = python3 + " " + soft +\
				" --multiKmer_sorted_scores_files " + ' '.join(multiKmer_score_files) +\
				" --multiKmer_seqs_files " + ' '.join(multiKmer_seq_files) +\
				" --missing_genes " + ' '.join(missing_PCGs) +\
				" --outprefix " + outprefix +\
				" --blastn  " + blastn
		runcmd(command)

		mitoscaf_file = outprefix + '.multiKmer_seq_picked.clean.fa'
		if not os.path.exists(mitoscaf_file):
			sys.exit('multi-kmer mode got no result!')

		# check if the result is circular
		# if yes, remove the overlapping region
		mitoscaf_file = quick_circle_check(
			bin_common_dir=bin_common_dir,
			mitoscaf_file=mitoscaf_file,
			prefix=outprefix)

		return abspath(mitoscaf_file)


def get_multiKmer_seq_and_score_files(nhmmer_result_dir=None, kmer=None):
	score_file = os.path.join(nhmmer_result_dir, 'work{0}.hmmtblout.besthit.sim.filtered.high_abundance_*X.reformat.sorted'.format(kmer))
	if len(glob(score_file)) == 1:
		score_file = glob(score_file)[0]

	seq_file = os.path.join(nhmmer_result_dir, 'work{0}.hmmtblout.besthit.sim.filtered.fa'.format(kmer))

	if os.path.exists(score_file) and os.path.exists(seq_file):
		if file_not_empty(score_file) and file_not_empty(seq_file):
			return score_file, seq_file
		else:
			return "", ""
	else:
		return "", ""


def assemble_soaptrans(assemble_wdir=None, soaptrans=None, soaptrans_thread_number=None, fq1=None, fq2=None, fastq_read_length=None, insert_size=None, kmer=71, prefix="work71", usepre=False):
	"""
	de novo with soaptrans, then find mitosequences

	"""
	assembly_file = ""

	if usepre:
		assembly_file = os.path.join(assemble_wdir, prefix + ".scafSeq")
		if os.path.exists(assembly_file):
			print("use previous result files:\n\t" + assembly_file + "\n",
				flush=True)
			# gather_result(assembly_file)
			return assembly_file

	trans_lib_f = prefix + ".soaptrans.lib"
	fh_tmp = open(trans_lib_f, 'w')
	tmp_out = ""
	tmp_out = "max_rd_len=%s\n" % fastq_read_length + \
		"[LIB]\n" + \
		"avg_ins=%s\n" % insert_size + \
		"reverse_seq=0\n" + \
		"asm_flags=3\n" + \
		"map_len=32\n"

	# pair end data
	if fq1 and fq2 and os.path.isfile(fq1) and os.path.isfile(fq2):
		tmp_out += "q1=" + fq1 + "\n" + "q2=" + fq2
	elif fq1 and os.path.isfile(fq1):
		# single end data
		tmp_out += "q=" + fq1
	elif fq2 and os.path.isfile(fq2):
		# single end data
		tmp_out += "q=" + fq2
	else:
		sys.exit('must set at least one of the fq1 and fq2!')

	print(tmp_out, file=fh_tmp)
	fh_tmp.close()

	command = soaptrans + " all " +\
				" -K " + str(kmer) +\
				" -o " + prefix +\
				" -s " + trans_lib_f +\
				" -p " + soaptrans_thread_number

	runcmd(command)

	files_to_del = ".Arc .ContigIndex .PEreadOnContig.gz" +\
				" .agp .contig .ctg2Read .edge.gz .gapSeq .kmerFreq" +\
				" .newContigIndex .peGrads .preArc .preGraphBasic" +\
				" .readInGap .readInformation .readOnContig .readOnScaf" +\
				" .scaf_gap .shortreadInGap.gz .updated.edge" +\
				" .vertex"

	command = pre_del_cmd(prefix=prefix, filestr=files_to_del)
	runcmd(command)

	assembly_file = abspath(prefix + ".scafSeq")

	if os.path.exists(assembly_file):
		# gather_result(assembly_file)
		return assembly_file
	else:
		sys.exit("Can not find " + assembly_file)


def findmitoscaf(bin_findmitoscaf_dir=None, bin_annotate_dir=None, bin_common_dir=None, assembly_file=None, from_soaptrans=False, fq1=None, fq2=None, fastq_quality_shift=False, nhmmer_profile=None, requiring_taxa=None, require_genetic_code=None, requiring_relax=None, MT_annotation_BGI=None, MT_annotation_BGI_pro_db=None, filter_taxa_method=None, blastn=None, samtools=None, bwa=None, thread_number=None, prefix="work", fastq_read_length=None, min_abundance=10):

	"""
	find candidate mitochondrial sequences, about 2-3 Gbp fastq data is
	needed to calculate the average sequencing depth of each sequences. Unless
	the input assembly is from SOAPTrans (specify with --from_soaptrans option)

	"""

	if (not from_soaptrans) and (not files_exist_0_or_1([fq1, fq2])):
		soft = os.path.join(bin_findmitoscaf_dir, "cal_bwa_abundance.py")
		abun_out_file = os.path.basename(assembly_file) + ".abun.fa"
		command = python3 + " " + soft +\
				" -fa " + assembly_file +\
				" -fq1 " + fq1 +\
				" -fq2 " + fq2 +\
				" -out " + abun_out_file +\
				" -fastq_read_length " + fastq_read_length +\
				" -bwa " + bwa +\
				" -samtools " + samtools +\
				" -thread " + thread_number
		if fastq_quality_shift:
			command += " -fastq_quality_shift "

		runcmd(command)
		assembly_file = abun_out_file

	mitoscaf_file, hmm_outf_tbl_besthit_sim_reformat_sorted_picked_stat= \
		findmitoscaf_nhmmer(bin_findmitoscaf_dir=bin_findmitoscaf_dir,
			bin_annotate_dir=bin_annotate_dir,
			assembly_file=assembly_file,
			nhmmer_profile=nhmmer_profile,
			requiring_taxa=requiring_taxa,
			require_genetic_code=require_genetic_code,
			requiring_relax=requiring_relax,
			MT_annotation_BGI=MT_annotation_BGI,
			MT_annotation_BGI_pro_db=MT_annotation_BGI_pro_db,
			filter_taxa_method=filter_taxa_method,
			blastn=blastn,
			thread_number=thread_number,
			prefix=prefix,
			min_abundance=min_abundance)

	if not mitoscaf_file:
		# file is empty
		return ("", 0, [0])

	# check if the result is circular
	# if yes, remove the overlapping region
	mitoscaf_file = quick_circle_check(
		bin_common_dir=bin_common_dir,
		mitoscaf_file=mitoscaf_file,
		prefix=prefix)

	# find the most related species
	soft = os.path.join(bin_findmitoscaf_dir, 'pick_most_related_sp.py')
	most_related_sp_file = prefix + '.most_related_species.txt'
	cds_taxa_file = glob(prefix+'*.hmmtblout.besthit.sim.fa.solar.genewise.gff.cds.position.cds.taxa')[0]
	command = python3 + " " + soft +\
		" " + cds_taxa_file +\
		" " + mitoscaf_file +\
		" " + most_related_sp_file
	runcmd(command)

	if args.command in ['assemble', 'findmitoscaf']:
		soft = os.path.join(bin_common_dir, 'summary_from_fasta_file.py')
		command = python3 + " " + soft +\
				" " + mitoscaf_file +\
				" " + most_related_sp_file +\
				" > summary.txt"

		runcmd(command)
		gather_result(mitoscaf_file, 'summary.txt')

	else:
		gather_result(mitoscaf_file, most_related_sp_file)

	fh_tmp = open(hmm_outf_tbl_besthit_sim_reformat_sorted_picked_stat, 'r')
	fh_tmp.readline()
	CDS_found_count = fh_tmp.readline().split()[0]
	fh_tmp.close()

	CDS_found_lengths = [0]
	for rec in SeqIO.parse(mitoscaf_file, 'fasta'):
		CDS_found_lengths.append(len(rec.seq))

	return (abspath(mitoscaf_file), CDS_found_count, CDS_found_lengths)


def findmitoscaf_nhmmer(bin_findmitoscaf_dir=None, bin_annotate_dir=None, assembly_file=None, nhmmer_profile=None, requiring_taxa=None, require_genetic_code=None, requiring_relax=None, MT_annotation_BGI=None, MT_annotation_BGI_pro_db=None, filter_taxa_method=None, blastn=None, thread_number=None, prefix=None, min_abundance=10):
	"""
	find potential mito-sequences from assembly by nhmmer searching.

	Here, we use pre-defined HMM modules, which should include 13 CDS genes.

	Further more, we can also filter out non-target-taxa mito-sequences by
	CDS annotatin.

	Then, we classify the annotated CDS genes as complete (digital 4), partial
	(digital 2) and not avaiable (a dot).

	We then sort the potentail mito-sequences by their scores. A score equals
	to C * sigma(Pi), while Pi is the length-completeness of each gene in one
	sequences (N Pi's in one sequence). Here, a pre-defined CDS length for
	coressponding taxa is used.

	High scores seqeunces will be selected firstly. For example, if cox1
	(4, for complete) is selected already, then another cox1 will not be
	selected. But if the first cox1 is 2 (for partial), then a second cox1 will
	be selected.

	However, if one seqeunce has 5 or more than 5 genes, it will be selected,
	too.

	"""


	# nhmmer needs uncompress input fasta file when multiple hmm profiles
	# in one file
	hmm_infile = assembly_file
	if assembly_file.endswith(".gz"):
		hmm_infile = prefix + ".tmp.nhmmer.infile"
		command = "gzip -dc " + assembly_file + " > " + hmm_infile
		runcmd(command)

	## do nhmmer
	hmm_outf = prefix + ".hmmout"
	hmm_outf_tbl = prefix + ".hmmtblout"
	command = nhmmer + " -o " + hmm_outf + " --tblout " + hmm_outf_tbl +\
			" --cpu " + thread_number + " " + nhmmer_profile +\
			" " + hmm_infile
	runcmd(command)


	## get besthit of HMM genes for each sequence
	hmm_outf_tbl_besthit = prefix + ".hmmtblout.besthit"
	soft = os.path.join(bin_findmitoscaf_dir,
		"get_besthit_of_each_CDS_from_nhmmer.py")
	command = python3 + " " + soft +\
		" " + hmm_outf_tbl +\
		" " + hmm_outf_tbl_besthit
	runcmd(command)

	## discard some fields of nhmmer result
	hmm_outf_tbl_besthit_sim = prefix + ".hmmtblout.besthit.sim"
	soft = os.path.join(bin_findmitoscaf_dir, "simlify_nhmmer_tbl_besthit.py")
	command = python3 + " " + soft +\
		" " + hmm_outf_tbl_besthit +\
		" " + hmm_outf_tbl_besthit_sim
	runcmd(command)


	# optional: filter out non-target-taxa sequences
	if filter_taxa_method == 3:
		# do not filter
		pass

	elif (filter_taxa_method == 1) and requiring_taxa:
		#
		# 1. extract all hmm besthit sequences
		#
		hmm_besthit_fa = hmm_outf_tbl_besthit_sim + ".fa"
		soft = os.path.join(bin_findmitoscaf_dir, "extract_fasta.py")
		command = python3 + " " + soft +\
			" -i " + hmm_infile +\
			" -q " + hmm_outf_tbl_besthit_sim +\
			" -o " + hmm_besthit_fa
		runcmd(command)

		if not file_not_empty(hmm_besthit_fa):
			return ("", "")

		# 2. filter taxonomy by MT PCGs annotation
		hmm_besthit_filtered_fa = hmm_outf_tbl_besthit_sim + ".filtered.fa"

		WISECONFIGDIR = os.path.join(bin_annotate_dir, "wisecfg")
		soft = os.path.join(bin_findmitoscaf_dir,
			"filter_taxonomy_by_CDS_annotation.py")
		command = python3 + " " + soft +\
			" -fa " + hmm_besthit_fa +\
			" -MTsoft " + MT_annotation_BGI +\
			" -db " + MT_annotation_BGI_pro_db +\
			" -thread " + thread_number +\
			" -genetic_code " + require_genetic_code +\
			" -requiring_taxa " + "'" + requiring_taxa + "'" +\
			" -relax " + requiring_relax +\
			" -WISECONFIGDIR " + WISECONFIGDIR +\
			" -outf " + hmm_besthit_filtered_fa
		runcmd(command)

		# 3. filter the 'hmm_outf_tbl_besthit_sim' file
		hmm_outf_tbl_besthit_sim_filtered = \
			hmm_outf_tbl_besthit_sim + ".filtered"
		soft = os.path.join(bin_findmitoscaf_dir, "filter_hmm-besthit-sim.py")
		command = python3 + " " + soft +\
			" " + hmm_besthit_filtered_fa +\
			" " + hmm_outf_tbl_besthit_sim +\
			" " + hmm_outf_tbl_besthit_sim_filtered
		runcmd(command)

		hmm_outf_tbl_besthit_sim = hmm_outf_tbl_besthit_sim_filtered

	else:
		print("do not filter non-requiring-taxa-sequences, because '--requiring_taxa' was not specified.", file=sys.stderr)

	## filter sequences with abundance < 10X
	# high_abun_sim = '{0}.high_abundance_{1}X'.format(hmm_outf_tbl_besthit_sim, min_abundance)
	soft = os.path.join(bin_assemble_dir, 'filter_by_abundance.py')
	command = python3 + " " + soft +\
		' {0} '.format(min_abundance) +\
		' {0} '.format(hmm_outf_tbl_besthit_sim) +\
		' {0} '.format(hmm_infile)
	runcmd(command)
	# must after running the above command, check the result file
	high_abun_sim = glob('{0}.high_abundance_*'.format(hmm_outf_tbl_besthit_sim))[0]
	if file_not_empty(high_abun_sim):
		hmm_outf_tbl_besthit_sim = high_abun_sim
	else:
		print('All sequences are low abundance (<{0}X)'.format(min_abundance), file=sys.stderr)
		return None, None

	## reformat to fasta-like format
	hmm_outf_tbl_besthit_sim_reformat = hmm_outf_tbl_besthit_sim + ".reformat"
	soft = os.path.join(bin_findmitoscaf_dir, "reformat_nhmmer_besthit-sim.py")
	command = python3 + " " + soft +\
			" " + hmm_outf_tbl_besthit_sim +\
			" " + hmm_outf_tbl_besthit_sim_reformat
	runcmd(command)

	## scoring and sorting
	hmm_outf_tbl_besthit_sim_reformat_sorted = \
		hmm_outf_tbl_besthit_sim + ".reformat.sorted"
	soft = os.path.join(bin_findmitoscaf_dir,
						"scoring_nhmmer_besthit_sim_reformat.py")
	command = python3 + " " + soft +\
			" " + defined_gene_length_f +\
			" " + hmm_outf_tbl_besthit_sim_reformat +\
			" " + hmm_outf_tbl_besthit_sim_reformat_sorted
	runcmd(command)

	## picking by dotting method
	hmm_outf_tbl_besthit_sim_reformat_sorted_dotted = \
		hmm_outf_tbl_besthit_sim + ".reformat.sorted.dotted"
	hmm_outf_tbl_besthit_sim_reformat_sorted_picked = \
		hmm_outf_tbl_besthit_sim + ".reformat.sorted.picked"
	hmm_outf_tbl_besthit_sim_reformat_sorted_picked_stat = \
		hmm_outf_tbl_besthit_sim + ".reformat.sorted.picked.stat"
	soft = os.path.join(bin_findmitoscaf_dir,
		"pick_seq_from_scoing_result_base_arr_v4.py")
	command = python3 + " " + soft +\
			" " + hmm_outf_tbl_besthit_sim_reformat_sorted +\
			" " + hmm_outf_tbl_besthit_sim_reformat_sorted_dotted +\
			" " + hmm_outf_tbl_besthit_sim_reformat_sorted_picked +\
			" " + hmm_outf_tbl_besthit_sim_reformat_sorted_picked_stat
	runcmd(command)

	## extract picked fasta sequences
	soft = os.path.join(bin_findmitoscaf_dir, "extract_nhmmer_seq_v2.py")
	hmm_outf_fa = hmm_outf + ".fa"
	command = python3 + " " + soft +\
			" -f " + hmm_outf_tbl_besthit_sim_reformat_sorted_picked +\
			" -d " + hmm_infile +\
			" -o " + hmm_outf_fa
	runcmd(command)

	## extract the not-picked fasta sequences
	soft = os.path.join(bin_findmitoscaf_dir, "extract_Not-picked-seq.py")
	hmm_outf_tbl_besthit_sim_reformat_sorted_Not_picked = \
		hmm_outf_tbl_besthit_sim + ".reformat.sorted.Not-picked"
	hmm_outf_tbl_besthit_sim_reformat_sorted_Not_picked_fa = hmm_outf_tbl_besthit_sim_reformat_sorted_Not_picked + '.fa'
	command = python3 + " " + soft +\
		" " + hmm_outf_tbl_besthit_sim_reformat_sorted +\
		" " + hmm_outf_tbl_besthit_sim_reformat_sorted_picked +\
		" " + hmm_infile +\
		" " + hmm_outf_tbl_besthit_sim_reformat_sorted_Not_picked +\
		" " + hmm_outf_tbl_besthit_sim_reformat_sorted_Not_picked_fa
	runcmd(command)

	gather_result(hmm_outf_tbl_besthit_sim_reformat_sorted_Not_picked, hmm_outf_tbl_besthit_sim_reformat_sorted_Not_picked_fa)

	# and gather the low abundance sequences
	low_abundance_files = glob('*low_abundance*')
	gather_result(*low_abundance_files)


	# check result file
	if file_not_empty(hmm_outf_fa):
		# gather_result(hmm_outf_fa,
		#			hmm_outf_tbl_besthit_sim_reformat_sorted_picked_stat)
		return abspath(hmm_outf_fa,
					hmm_outf_tbl_besthit_sim_reformat_sorted_picked_stat)
	else:
		sys.exit("can not find any mitosequences by nhmmer!")


def reads_mapping(bin_common_dir=None, mitoscaf_file=None, fq1=None, fq2=None, fastq_quality_shift=None, bwa=None, samtools=None, thread_number=None, prefix=None):
	"""
	mapping reads to sequences

	"""

	# if file is not in current directory, soft link
	dirname = os.path.dirname(abspath(mitoscaf_file))
	basename = os.path.basename(mitoscaf_file)
	current_dir = os.getcwd()
	if dirname != current_dir:
		command = "ln -s " + mitoscaf_file + " "  + basename
		runcmd(command)
		mitoscaf_file = basename

	## bwa indexing
	command = bwa + " index " + mitoscaf_file
	runcmd(command)

	q1_sai = "q1.sai"
	q2_sai = "q2.sai"
	if fastq_quality_shift:
		command = bwa + " aln" +\
				" -n 0 -o 0 -I" +\
				" -t " + thread_number +\
				" -f " + q1_sai +\
				" " + mitoscaf_file +\
				" " + fq1
		runcmd(command)

		command = bwa + " aln" +\
				" -n 0 -o 0 -I" +\
				" -t " + thread_number +\
				" -f " + q2_sai +\
				" " +  mitoscaf_file +\
				" " + fq2
		runcmd(command)

	else:
		command = bwa + " aln" +\
				" -n 0 -o 0" +\
				" -t " + thread_number +\
				" -f " + q1_sai +\
				" " + mitoscaf_file +\
				" " + fq1
		runcmd(command)

		command = bwa + " aln" +\
				" -n 0 -o 0" +\
				" -t " + thread_number +\
				" -f " + q2_sai +\
				" " +  mitoscaf_file +\
				" " + fq2
		runcmd(command)

	bwa_sam = "bwa.sam"
	command = bwa + " sampe" +\
			" " + mitoscaf_file +\
			" " + q1_sai +\
			" " + q2_sai +\
			" " + fq1 +\
			" " + fq2 +\
			" | " + samtools + " view -h -F 4 - > " + bwa_sam
	runcmd(command)

	soft = os.path.join(bin_common_dir, "get_mapped_sam.py")
	bwa_mapped_sam = "bwa_mapped.sam"
	bwa_sam_depth = mitoscaf_file + ".depth"
	## set sequencing depth file
	args.depth_file = bwa_sam_depth
	command = python3 + " " + soft +\
			" " + bwa_sam +\
			" " + "%sM" % args.fastq_read_length +\
			" " + bwa_mapped_sam +\
			" " + bwa_sam_depth
	runcmd(command)

	## gc and coverage of sequences
	soft = os.path.join(bin_common_dir, "gc_and_coverage_of_fasta.py")
	outfile = prefix + basename
	command = python3 + " " + soft +\
			" -i " + mitoscaf_file +\
			" -d " + bwa_sam_depth +\
			" -o " + outfile
	runcmd(command)

	command = "rm -rf *.amb *.ann *.bwt *.pac *.rbwt *.rsa *.sa *.rpac"
	command += " *.sai bwa.sam"
	runcmd(command)

	# gather_result(bwa_mapped_sam, bwa_sam_depth)

	return abspath(bwa_mapped_sam, bwa_sam_depth)


def circle_check(bin_common_dir=None, mitoscaf_file=None, fq1=None, fq2=None, fastq_quality_shift=None, bwa=None, samtools=None, thread_number=None, prefix=None):
	"""
	check if sequences are circular (seq length >= 12Kbp).

	"""
	circle_result_file = "circular.check"

	soft = os.path.join(bin_common_dir, "circle_check.py")
	command = python3 + " " + soft +\
			" " + mitoscaf_file +\
			" " + circle_result_file +\
			" 3"
	runcmd(command)

	circle = 0
	if file_not_empty(circle_result_file):
		circle = 1
		args.topology = "circular"
		bwa_mapped_sam, bwa_sam_depth = reads_mapping(
			bin_common_dir=bin_common_dir,
			mitoscaf_file="circular.check.start2end",
			fq1=fq1,
			fq2=fq2,
			fastq_quality_shift=fastq_quality_shift,
			bwa=bwa,
			samtools=samtools,
			thread_number=thread_number,
			prefix=prefix)

		gather_result(circle_result_file, bwa_mapped_sam,
			"circular.check.start2end", "circular.check.overlap_information")

		return ([circle] + abspath("circular.check.start2end", bwa_mapped_sam))

	else:
		bwa_mapped_sam, bwa_sam_depth = reads_mapping(
			bin_common_dir=bin_common_dir,
			mitoscaf_file=mitoscaf_file,
			fq1=fq1,
			fq2=fq2,
			fastq_quality_shift=fastq_quality_shift,
			bwa=bwa,
			samtools=samtools,
			thread_number=thread_number,
			prefix=prefix)

		gather_result(bwa_mapped_sam)

		return ([circle] + abspath(mitoscaf_file, bwa_mapped_sam))


def quick_circle_check(bin_common_dir=None, mitoscaf_file=None, prefix='ZZZ'):
	"""
	check if sequences are circular (seq length >= 12Kbp), do not map reads
	to mitoscaf with bwa

	"""
	mt_file = "{0}.mitogenome.fa".format(prefix)

	soft = os.path.join(bin_common_dir, "circle_check.py")
	command = python3 + " " + soft +\
			" " + mitoscaf_file +\
			" " + prefix +\
			" 3"
	runcmd(command)

	return mt_file


def file_not_empty(file=None):
	"""
	check if file is empty

	"""
	if os.stat(file).st_size > 0:
		return True
	else:
		return False


def annotate(bin_annotate_dir=None, annotate_wdir=None, mitoscaf_file=None, MT_annotation_BGI=None, MT_annotation_BGI_pro_db=None, cmsearch=None, s_rRNA_CM=None, l_rRNA_CM=None, species_name=None, topology="linear", genetic_code=None, thread_number=None, prefix=None, fq1=None, fq2=None):
	"""
	mito annotation, including CDS, tRNA, rRNA, and generate genbank/sqn files

	"""
	os.mkdir(annotate_wdir)
	os.chdir(annotate_wdir)

	annotation_infile = prefix + "_mitoscaf.fa"
	fh_out = open(annotation_infile, 'w')
	for rec in SeqIO.parse(mitoscaf_file, 'fasta'):
		print(">"+rec.id+"\n"+str(rec.seq), file=fh_out)
	fh_out.close()


	## CDS annotation
	WISECONFIGDIR = os.path.join(bin_annotate_dir, "wisecfg")
	command = "export WISECONFIGDIR=%s\n" % WISECONFIGDIR
	# must cat export and perl command together here
	soft = MT_annotation_BGI
	command += "perl " + soft +\
			" -i " + annotation_infile +\
			" -d " + MT_annotation_BGI_pro_db +\
			" -o ./" +\
			" -g " + genetic_code +\
			" -cpu " + thread_number
	runcmd(command)

	command = "rm -rf *.nhr *.nin *.nsq formatdb.log *.tblastn.shell *.length"
	command += " *.blast *.blast.filter *.shell *.blast.solar"
	command += " *.blast.solar.filter *.blast.solar.filter.table"
	command += " *.blast.solar.filter.table.nonredundance"
	command += " *.blast.solar.filter.nr *.genewise *.solar.genewise.gff"
	command += " *.solar.genewise.gff.cds"
	runcmd(command)

	soft = os.path.join(bin_annotate_dir, 'prepare_CDSposition.py')
	MT_annotation_BGI_outfile = annotation_infile +\
		".solar.genewise.gff.cds.position.cds"
	cds_position = prefix + ".cds.position"
	command = python3 + " " + soft +\
			" " + MT_annotation_BGI_outfile +\
			" " + cds_position
	runcmd(command)

	# get the most related species information
	soft = os.path.join(bin_annotate_dir, 'pick_most_related_sp_from_position_cds.py')
	annt_most_related_sp_file = prefix + '.most_related_species.txt'
	command = python3 + " " + soft +\
			" " + MT_annotation_BGI_outfile +\
			" " + annotation_infile +\
			" {0} ".format(annt_most_related_sp_file)
	runcmd(command)
	# gather_result(annt_most_related_sp_file)

	cds_position_sorted = cds_position + ".sorted"
	command = "sort -k1,1 -k6,6n " + cds_position + " >" + cds_position_sorted
	runcmd(command)

	## find positions of start codon and stop codon
	soft = os.path.join(bin_annotate_dir, 'revise_CDS_pos_v6.py')
	cds_position_revised = cds_position_sorted + ".revised"
	command = python3 + " " + soft +\
			" " + annotation_infile +\
			" " + cds_position_sorted +\
			" " + genetic_code +\
			" " + cds_position_revised
	runcmd(command)


	# filter out some cds with quite short annotated regions
	cds_position_revised_filtered = cds_position_revised + ".filtered"
	soft = os.path.join(bin_annotate_dir, "filter_cds_by_annotated-len.py")
	command = python3 + " " + soft +\
		" " + cds_position_revised +\
		" " + cds_position_revised_filtered +\
		" 0.8 "
	runcmd(command)

	cds_position_revised = cds_position_revised_filtered

	## prepare CDS feature table file
	soft = os.path.join(bin_annotate_dir, 'cds_ft_v2.py')
	annotation_infile_cdsft = annotation_infile + ".cds.ft"
	command = python3 + " " + soft +\
			" " + cds_position_revised +\
			" " + genetic_code +\
			" " + annotation_infile_cdsft
	runcmd(command)


	## tRNA annotation
	mitfipath = os.path.join(bin_annotate_dir, "mitfi")

	annotation_infile2 = abspath(annotation_infile)
	trna_out = annotation_infile + ".trna"
	trna_out = abspath(trna_out)

	command = "## begin tRNA annotation...\n" +\
			"## remove previous tRNA result file (if any)\n" +\
			"rm -rf " + trna_out
	runcmd(command)

	# one sequence by one sequence
	for rec in SeqIO.parse(annotation_infile2, 'fasta'):
		tmp_file = annotation_infile2 + "." + rec.id
		fh_tmp = open(tmp_file, 'w')
		SeqIO.write(rec, fh_tmp, 'fasta')
		fh_tmp.close()

		## MiTFi will get no results when use multiple cores!!
		## must cat cd command to java command together here
		command = "cd " + mitfipath + "\n"
		command += "java -Xmx2048m -jar mitfi.jar -cores 1 " +\
			" -code " + args.genetic_code +\
			" -evalue 0.001" +\
			" -onlycutoff" +\
			" " + tmp_file + " >>" + trna_out
		runcmd(command)

		command = "rm -rf " + tmp_file
		runcmd(command)

	## prepare tRNA feature table file
	soft = os.path.join(bin_annotate_dir, "tRNA_ft_mitfi.py")
	annotation_infile_trnaft = trna_out + ".ft"

	command = python3 + " " + soft +\
			" " + trna_out +\
			" " + annotation_infile_trnaft
	runcmd(command)


	## rRNA annotation
	# s-rRNA
	cmsearch_s_rRNA_result = annotation_infile + ".s-rRNA.out"
	cmsearch_s_rRNA_tbl_result = annotation_infile + ".s-rRNA.tbl"

	# firstly, use global searching
	soft = cmsearch
	command = soft +\
			" -g --tblout " + cmsearch_s_rRNA_tbl_result +\
			" --cpu " + args.thread_number +\
			" " + s_rRNA_CM +\
			" " + annotation_infile +\
			" >" + cmsearch_s_rRNA_result
	runcmd(command)

	# then, check if the result is empty.
	# If empty, use local searching,
	# otherwise, process the result
	if not check_cmsearch_global(cmsearch_s_rRNA_tbl_result):
		print("global cmsearch could not find results! Now try local cmsearch")
		soft = cmsearch
		command = soft +\
			" --tblout " + cmsearch_s_rRNA_tbl_result +\
			" --cpu " + args.thread_number +\
			" " + s_rRNA_CM +\
			" " + annotation_infile +\
			" >" + cmsearch_s_rRNA_result
		runcmd(command)


	s_rRNA_ft = annotation_infile + ".s-rRNA.ft"
	soft = os.path.join(bin_annotate_dir, "rRNA_ft.py")
	command = python3 + " " + soft +\
			" " + cmsearch_s_rRNA_tbl_result +\
			" " + s_rRNA_ft
	runcmd(command)


	# l-rRNA
	cmsearch_l_rRNA_result = annotation_infile + ".l-rRNA.out"
	cmsearch_l_rRNA_tbl_result = annotation_infile + ".l-rRNA.tbl"

	# firstly, use global searching
	soft = cmsearch
	command = soft +\
			" -g --tblout " + cmsearch_l_rRNA_tbl_result +\
			" --cpu " + thread_number +\
			" " + l_rRNA_CM +\
			" " + annotation_infile +\
			" >" + cmsearch_l_rRNA_result
	runcmd(command)

	# then, check if the result is empty.
	# If empty, use local searching,
	# otherwise, process the result
	if not check_cmsearch_global(cmsearch_l_rRNA_tbl_result):
		print("global cmsearch could not find results! Now try local cmsearch")
		soft = cmsearch
		command = soft +\
			" --tblout " + cmsearch_l_rRNA_tbl_result +\
			" --cpu " + thread_number +\
			" " + l_rRNA_CM +\
			" " + annotation_infile +\
			" >" + cmsearch_l_rRNA_result
		runcmd(command)


	l_rRNA_ft = annotation_infile + ".l-rRNA.ft"
	soft = os.path.join(bin_annotate_dir, "rRNA_ft.py")
	command = python3 + " " + soft +\
			" " + cmsearch_l_rRNA_tbl_result +\
			" " + l_rRNA_ft
	runcmd(command)


	## combine CDS and RNA annotation into a feature table file
	## check file existing before join!!
	annot_fail_count = 0
	soft = os.path.join(bin_annotate_dir, 'join_ft.py')
	tbl_file = annotation_infile + ".tbl"
	command = python3 + " " + soft +\
			" " + tbl_file

	if file_not_empty(annotation_infile_cdsft):
		command += " " + annotation_infile_cdsft
	else:
		print("can not find CDS!", file=sys.stderr)
		annot_fail_count += 1

	if file_not_empty(annotation_infile_trnaft):
		command += " " + annotation_infile_trnaft
	else:
		print("can not find tRNAs!", file=sys.stderr)
		annot_fail_count += 1

	if file_not_empty(s_rRNA_ft):
		command += " " + s_rRNA_ft
	else:
		print("can not find s-rRNA!", file=sys.stderr)
		annot_fail_count += 1

	if file_not_empty(l_rRNA_ft):
		command += " " + l_rRNA_ft
	else:
		print("can not find l-rRNA!", file=sys.stderr)
		annot_fail_count += 1

	if annot_fail_count == 4:
		sys.exit("Can not find any genes!")

	runcmd(command)


	# find control region
	control_region_ft = annotation_infile + ".control_region.ft"
	if file_not_empty(annotation_infile_cdsft) and file_not_empty(annotation_infile_trnaft) and file_not_empty(s_rRNA_ft) and file_not_empty(l_rRNA_ft):
		soft = os.path.join(bin_annotate_dir, 'find_contro_region.py')
		command = python3 + " " + soft +\
				" -fa_file " + mitoscaf_file +\
				" -PCG_cutoff_file " + defined_gene_length_f +\
				" -PCG_len_ratio 0.9 " +\
				" -s_rRNA_CM_file " + s_rRNA_CM +\
				" -l_rRNA_CM_file " + l_rRNA_CM +\
				" -rRNA_len_ratio 0.9 "  +\
				" -tRNA_num_min 22 "  +\
				" -fea_files " + " ".join([annotation_infile_cdsft, annotation_infile_trnaft, s_rRNA_ft, l_rRNA_ft]) +\
				" -CR_len_min 600 " +\
				" -outfile " + control_region_ft
		runcmd(command)

		command = 'cat {0} >> {1}'.format(control_region_ft, tbl_file)
		runcmd(command)

	# prepare a *.fsa file
	soft = os.path.join(bin_annotate_dir, 'prepare_fsa.py')
	fsa_file = annotation_infile + ".fsa"
	command = python3 + " " + soft +\
				" " + mitoscaf_file +\
				" '%s'" % species_name +\
				" " + genetic_code +\
				" " + fsa_file
	runcmd(command)

	# use the NCBI sequin soft
	soft = 'tbl2asn'
	template_sbt = os.path.join(bin_annotate_dir, 'template.sbt')
	command = soft +\
			" -t " + template_sbt +\
			" -a s -p . -V vb"
	runcmd2(command)


	# for the GenBank file,
	# 1. get a gene stats
	tbl2asn_gbf = annotation_infile + ".gbf"

	soft = os.path.join(bin_common_dir, 'genbank_gene_stat_v2.py')
	command = python3 + " " + soft +\
				" " + tbl2asn_gbf +\
				" " + annt_most_related_sp_file +\
				" " + args.command +\
				" > summary.txt"
	runcmd(command)

	# 2. extract all gene sequences
	soft = os.path.join(bin_common_dir, 'gbseqextractor_v2.py')
	command = python3 + " " + soft +\
				" -f " + tbl2asn_gbf + \
				" -prefix " + prefix + \
				" -types CDS rRNA tRNA wholeseq misc_feature -p -l -rv "
	runcmd(command)
	# gene sequence files
	cds_file = prefix + '.cds'
	trna_file = prefix + '.trna'
	rrna_file = prefix + '.rrna'
	control_region_file = prefix + '.misc_feature'
	whole_mt_file = prefix + '.fasta'

	# gather_result(fsa_file, cds_position, cds_position_revised, annotation_infile_cdsft, annotation_infile_trnaft, s_rRNA_ft,
	#	l_rRNA_ft, tbl_file)

	gather_result(tbl_file, 'summary.txt', cds_file, trna_file, rrna_file, control_region_file, whole_mt_file)


	tbl2asn_tbl = annotation_infile + ".tbl"
	tbl2asn_fsa = annotation_infile + ".fsa"
	tbl2asn_sqn = annotation_infile + ".sqn"
	tbl2asn_val = annotation_infile + ".val"

	## visualization of genbank file
	if fq1 and os.path.isfile(fq1) and fq2 and os.path.isfile(fq2):
		command = " --gb {gbfile} --gc yes --run_map yes --thread {thread} --fq1 {fq1} --fq2 {fq2} --outdir visualization ".format(gbfile=tbl2asn_gbf, thread=thread_number, fq1=fq1, fq2=fq2)

	elif fq1 and os.path.isfile(fq1):
		command = " --gb {gbfile} --gc yes --run_map yes --thread {thread} --fq1 {fq1}  --outdir visualization ".format(gbfile=tbl2asn_gbf, thread=thread_number, fq1=fq1)

	elif fq2 and os.path.isfile(fq2):
		command = " --gb {gbfile} --gc yes --run_map yes --thread {thread} --fq1 {fq2}  --outdir visualization ".format(gbfile=tbl2asn_gbf, thread=thread_number, fq2=fq2)
	else:
		command = " --gb {gbfile} --gc yes --outdir visualization ".format(gbfile=tbl2asn_gbf)

	print('visualization command:\n', command, flush=True)
	MitoZ_visualize.main(para_list=command.split())

	## simple gene statistic for genbank file
	# soft = os.path.join(bin_annotate_dir, "gene_stat_from_genbank.py")
	# tbl2asn_gbf_stat = tbl2asn_gbf + ".statistic"
	# command = python3 + " " + soft +\
	#		" -i " + tbl2asn_gbf +\
	#		" -o " + tbl2asn_gbf_stat +\
	#		" -f "
	# runcmd(command)

	command = "cp " + tbl2asn_gbf +\
			" " + tbl2asn_sqn +\
			" " + tbl2asn_val + ' ' + result_wdir

	runcmd(command)

	command = 'cp errorsummary.val {dest}/{prefix}.errorsummary.val\n'.format(dest=result_wdir, prefix=prefix)

	command += 'cp visualization/circos.svg {dest}/{prefix}.circos.svg\n'.format(dest=result_wdir, prefix=prefix)

	command += 'cp visualization/circos.png {dest}/{prefix}.circos.png\n'.format(dest=result_wdir, prefix=prefix)

	# command += 'cp visualization/circos.karyotype.txt {dest}/{prefix}.circos.karyotype.txt\n'.format(dest=result_wdir, prefix=prefix)

	# command += 'cp visualization/circos.dep {dest}/{prefix}.circos.dep\n'.format(dest=result_wdir, prefix=prefix)

	runcmd(command)


	# need to check the distance of the duplicate genes!
	# and gene duplicate genes must have same direction
	# and cut sites not in gene overlapping regions if possible

	return (fsa_file, cds_position, cds_position_revised,
			annotation_infile_trnaft, s_rRNA_ft, l_rRNA_ft, tbl2asn_gbf)

def check_cmsearch_global(glresult=None):
		with open(glresult, 'r') as fh:
			fh.readline()
			fh.readline()
			i = fh.readline()
			if i.startswith("#"):
				return False
			else:
				return True


def check_requiring_taxa(taxa_name=None):
	ncbi = NCBITaxa()
	name_dict = ncbi.get_name_translator([taxa_name])
	if not name_dict:
		## try only the first word (which may be a genus name?)
		print("can not find taxid for", taxa_name, file=sys.stderr)
		taxa_name = taxa_name.split()
		if len(taxa_name) > 1:
			taxa_name = taxa_name[0]
			print("try to search %s instead..." % taxa_name, file=sys.stderr)
			name_dict = ncbi.get_name_translator([taxa_name])

		if not name_dict:
			print("can not find taxid for %s, maybe it's a misspelling.\n Please use other taxanomy name." % taxa_name , file=sys.stderr)
			sys.exit(0)

def gather_result(*files):
	if not os.path.isdir(result_wdir):
		os.mkdir(result_wdir)
	flist = " ".join(files)
	command = "cp " + flist + " " + result_wdir
	runcmd(command)



###############################################################################
###############################################################################

if args.command == "all":
	os.chdir(work_dir_tmp)
	program_begin_clock = time.clock()
	program_begin_wall = time.time()

	if args.requiring_taxa:
		check_requiring_taxa(args.requiring_taxa)

	if args.usepre:
		command = "rm -rf " + result_wdir + " " + annotate_wdir +\
				  " " + assemble_wdir2
		runcmd(command)
	else:
		directory_exist_check(clean_data_wdir, assemble_wdir, assemble_wdir2,
			annotate_wdir, result_wdir)

	## read length must be >= kmer 71
	if int(args.fastq_read_length) < 71:
		sys.exit("The read length of input fastq files must be >= 71 bp")

	##
	clean_fq1, clean_fq2 = filter_rawdata(
		bin_filter_dir=bin_filter_dir,
		clean_data_wdir=clean_data_wdir,
		raw_fq1=args.fastq1,
		raw_fq2=args.fastq2,
		adapter1=args.adapter1,
		adapter2=args.adapter2,
		clean_fq1=args.fastq3,
		clean_fq2=args.fastq4,
		usepre=args.usepre,
		adapter_mismatch=args.adapter_mismatch,
		adapter_length=args.adapter_length,
		Ns_number=args.Ns_number,
		low_quality=args.low_quality,
		keep_region=args.keep_region,
		duplication=args.duplication)

	mitoscaf_file = assemble(
		assemble_wdir=assemble_wdir,
		assemble_wdir2=assemble_wdir2,
		bin_assemble_dir=bin_assemble_dir,
		bin_findmitoscaf_dir=bin_findmitoscaf_dir,
		bin_annotate_dir=bin_annotate_dir,
		bin_common_dir=bin_common_dir,
		soaptrans=soaptrans,
		samtools=samtools,
		bwa=bwa,
		blastn=blastn,
		MT_annotation_BGI=MT_annotation_BGI,
		thread_number=args.thread_number,
		fq1=clean_fq1,
		fq2=clean_fq2,
		fastq_read_length=args.fastq_read_length,
		fastq_quality_shift=args.fastq_quality_shift,
		insert_size=args.insert_size,
		MT_annotation_BGI_pro_db=MT_annotation_BGI_pro_db_for_filter_taxa,
		nhmmer_profile=nhmmer_profile,
		requiring_taxa=args.requiring_taxa,
		requiring_relax=args.requiring_relax,
		require_genetic_code=args.genetic_code,
		filter_taxa_method=args.filter_taxa_method,
		run_mode=args.run_mode,
		quick_mode_seq_file=args.quick_mode_seq_file,
		quick_mode_fa_genes_file=args.quick_mode_fa_genes_file,
		missing_PCGs=args.missing_PCGs,
		quick_mode_score_file=args.quick_mode_score_file,
		quick_mode_prior_seq_file=args.quick_mode_prior_seq_file,
		usepre=args.usepre,
		outprefix=args.outprefix)


	if not mitoscaf_file:
		# file is empty
		sys.exit("mitoscaf_file is empty after run assemble() function!")

	if args.annotation:
		annotate(
			bin_annotate_dir=bin_annotate_dir,
			annotate_wdir=annotate_wdir,
			mitoscaf_file=mitoscaf_file,
			MT_annotation_BGI=MT_annotation_BGI,
			MT_annotation_BGI_pro_db=MT_annotation_BGI_pro_db_for_final_annotation,
			cmsearch=cmsearch,
			s_rRNA_CM=s_rRNA_CM,
			l_rRNA_CM=l_rRNA_CM,
			species_name=args.species_name,
			topology=args.topology,
			genetic_code=args.genetic_code,
			thread_number=args.thread_number,
			prefix=args.outprefix,
			fq1=args.fastq1,
			fq2=args.fastq2)

		os.chdir(work_dir)
		#gather_result(clean_data_wdir, assemble_wdir, assemble_wdir2,
		#		annotate_wdir)
	else:
		pass
		#gather_result(clean_data_wdir, assemble_wdir, assemble_wdir2)

	program_end_clock = time.clock()
	program_end_wall = time.time()

	print('running time:')
	print('CPU time:')


if args.command == "all2":
	os.chdir(work_dir_tmp)
	if args.requiring_taxa:
		check_requiring_taxa(args.requiring_taxa)

	if args.usepre:
		command = "rm -rf " + result_wdir + " " + annotate_wdir +\
				 " " + assemble_wdir2
		runcmd(command)
		#directory_exist_check(assemble_wdir2, result_wdir)
	else:
		directory_exist_check(assemble_wdir,assemble_wdir2, annotate_wdir,
			result_wdir)

	## read length must be >= kmer 71
	if int(args.fastq_read_length) < 71:
		sys.exit("The read length of input fastq files must be >= 71 bp")

	mitoscaf_file = assemble(
		assemble_wdir=assemble_wdir,
		assemble_wdir2=assemble_wdir2,
		bin_assemble_dir=bin_assemble_dir,
		bin_findmitoscaf_dir=bin_findmitoscaf_dir,
		bin_annotate_dir=bin_annotate_dir,
		bin_common_dir=bin_common_dir,
		soaptrans=soaptrans,
		samtools=samtools,
		bwa=bwa,
		blastn=blastn,
		MT_annotation_BGI=MT_annotation_BGI,
		thread_number=args.thread_number,
		fq1=args.fastq1,
		fq2=args.fastq2,
		fastq_read_length=args.fastq_read_length,
		fastq_quality_shift=args.fastq_quality_shift,
		insert_size=args.insert_size,
		MT_annotation_BGI_pro_db=MT_annotation_BGI_pro_db_for_filter_taxa,
		nhmmer_profile=nhmmer_profile,
		requiring_taxa=args.requiring_taxa,
		requiring_relax=args.requiring_relax,
		require_genetic_code=args.genetic_code,
		filter_taxa_method=args.filter_taxa_method,
		run_mode=args.run_mode,
		quick_mode_seq_file=args.quick_mode_seq_file,
		quick_mode_fa_genes_file=args.quick_mode_fa_genes_file,
		missing_PCGs=args.missing_PCGs,
		quick_mode_score_file=args.quick_mode_score_file,
		quick_mode_prior_seq_file=args.quick_mode_prior_seq_file,
		usepre=args.usepre,
		outprefix=args.outprefix)


	if not mitoscaf_file:
		# file is empty
		sys.exit("mitoscaf_file is empty after run assemble() function!")

	if args.annotation:
		annotate(bin_annotate_dir=bin_annotate_dir,
		annotate_wdir=annotate_wdir,
		mitoscaf_file=mitoscaf_file,
		MT_annotation_BGI=MT_annotation_BGI,
		MT_annotation_BGI_pro_db=MT_annotation_BGI_pro_db_for_final_annotation,
		cmsearch=cmsearch,
		s_rRNA_CM=s_rRNA_CM,
		l_rRNA_CM=l_rRNA_CM,
		species_name=args.species_name,
		topology=args.topology,
		genetic_code=args.genetic_code,
		thread_number=args.thread_number,
		prefix=args.outprefix,
		fq1=args.fastq1,
		fq2=args.fastq2)

		os.chdir(work_dir)
		#gather_result(clean_data_wdir, assemble_wdir, assemble_wdir2,
		#		annotate_wdir)
	else:
		pass
		#gather_result(assemble_wdir, assemble_wdir2)


if args.command == "filter":
	os.chdir(work_dir_tmp)
	directory_exist_check(clean_data_wdir)

	filter_rawdata(
		bin_filter_dir=bin_filter_dir,
		clean_data_wdir=clean_data_wdir,
		raw_fq1=args.fastq1,
		raw_fq2=args.fastq2,
		adapter1=args.adapter1,
		adapter2=args.adapter2,
		clean_fq1=args.fastq3,
		clean_fq2=args.fastq4,
		usepre=False,
		adapter_mismatch=args.adapter_mismatch,
		adapter_length=args.adapter_length,
		Ns_number=args.Ns_number,
		low_quality=args.low_quality,
		keep_region=args.keep_region,
		duplication=args.duplication)


if args.command == "assemble":
	os.chdir(work_dir_tmp)
	if args.requiring_taxa:
		check_requiring_taxa(args.requiring_taxa)

	if args.usepre:
		directory_exist_check(assemble_wdir2)
	else:
		directory_exist_check(assemble_wdir, assemble_wdir2)

	## read length must be >= kmer 71
	if int(args.fastq_read_length) < 71:
		sys.exit("The read length of input fastq files must be >= 71 bp")

	mitoscaf_file = assemble(
		assemble_wdir=assemble_wdir,
		assemble_wdir2=assemble_wdir2,
		bin_assemble_dir=bin_assemble_dir,
		bin_findmitoscaf_dir=bin_findmitoscaf_dir,
		bin_annotate_dir=bin_annotate_dir,
		bin_common_dir=bin_common_dir,
		soaptrans=soaptrans,
		samtools=samtools,
		bwa=bwa,
		blastn=blastn,
		MT_annotation_BGI=MT_annotation_BGI,
		thread_number=args.thread_number,
		fq1=args.fastq1,
		fq2=args.fastq2,
		fastq_read_length=args.fastq_read_length,
		fastq_quality_shift=args.fastq_quality_shift,
		insert_size=args.insert_size,
		MT_annotation_BGI_pro_db=MT_annotation_BGI_pro_db_for_filter_taxa,
		nhmmer_profile=nhmmer_profile,
		requiring_taxa=args.requiring_taxa,
		requiring_relax=args.requiring_relax,
		require_genetic_code=args.genetic_code,
		filter_taxa_method=args.filter_taxa_method,
		run_mode=args.run_mode,
		quick_mode_seq_file=args.quick_mode_seq_file,
		quick_mode_fa_genes_file=args.quick_mode_fa_genes_file,
		missing_PCGs=args.missing_PCGs,
		quick_mode_score_file=args.quick_mode_score_file,
		quick_mode_prior_seq_file=args.quick_mode_prior_seq_file,
		usepre=args.usepre,
		outprefix=args.outprefix)


if args.command == "findmitoscaf":
	os.chdir(work_dir_tmp)
	if args.requiring_taxa:
		check_requiring_taxa(args.requiring_taxa)

	mitoscaf_file, CDS_found_count, CDS_found_lengths = findmitoscaf(
		bin_findmitoscaf_dir=bin_findmitoscaf_dir,
		bin_annotate_dir=bin_annotate_dir,
		bin_common_dir=bin_common_dir,
		assembly_file=args.fastafile,
		from_soaptrans=args.from_soaptrans,
		fq1=args.fastq1,
		fq2=args.fastq2,
		fastq_quality_shift=args.fastq_quality_shift,
		nhmmer_profile=nhmmer_profile,
		requiring_taxa=args.requiring_taxa,
		require_genetic_code=args.genetic_code,
		requiring_relax=args.requiring_relax,
		MT_annotation_BGI=MT_annotation_BGI,
		MT_annotation_BGI_pro_db=MT_annotation_BGI_pro_db_for_filter_taxa,
		filter_taxa_method=args.filter_taxa_method,
		blastn=blastn,
		samtools=samtools,
		bwa=bwa,
		thread_number=args.thread_number,
		prefix=args.outprefix,
		fastq_read_length=args.fastq_read_length,
		min_abundance=args.min_abundance)

	gather_result(mitoscaf_file)


if args.command == "circle":
	os.chdir(work_dir_tmp)
	circle_check(
		bin_common_dir=bin_common_dir,
		mitoscaf_file=args.fastafile,
		fq1=args.fastq1,
		fq2=args.fastq2,
		fastq_quality_shift=args.fastq_quality_shift,
		bwa=bwa,
		samtools=samtools,
		thread_number=args.thread_number,
		prefix=args.outprefix)


if args.command == "annotate":
	os.chdir(work_dir_tmp)
	directory_exist_check(annotate_wdir)

	annotate(
		bin_annotate_dir=bin_annotate_dir,
		annotate_wdir=annotate_wdir,
		mitoscaf_file=args.fastafile,
		MT_annotation_BGI=MT_annotation_BGI,
		MT_annotation_BGI_pro_db=MT_annotation_BGI_pro_db_for_final_annotation,
		cmsearch=cmsearch,
		s_rRNA_CM=s_rRNA_CM,
		l_rRNA_CM=l_rRNA_CM,
		species_name=args.species_name,
		topology=args.topology,
		genetic_code=args.genetic_code,
		thread_number=args.thread_number,
		prefix=args.outprefix,
		fq1=args.fastq1,
		fq2=args.fastq2)


if args.command == "reconfirm":
	os.chdir(work_dir_tmp)
	reads_mapping(
		bin_common_dir=bin_common_dir,
		mitoscaf_file=args.fastafile,
		fq1=args.fastq1,
		fq2=args.fastq2,
		fastq_quality_shift=args.fastq_quality_shift,
		bwa=bwa,
		samtools=samtools,
		thread_number=args.thread_number,
		prefix=args.outprefix)


# to the result directory
# give instructions on what each file is
file_introduction = os.path.join(result_wdir, 'README.txt')
soft = os.path.join(bin_common_dir, 'get_result-dir_file_intro.py')
command = python3 + " " + soft +\
			" " + result_wdir +\
			" > " + file_introduction
runcmd(command)
